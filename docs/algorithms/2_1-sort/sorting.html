<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>Sorting</title>
</head>

<body>
<h1>Sorting</h1>
<p>&nbsp;</p>
<p><a href="https://www.toptal.com/developers/sorting-algorithms">Sorting Algorithms Animations</a> (Insertion, Selection, Bubble, Shell, Merge, Heap, Quick, Quick3)</p>
<p>&nbsp;</p>
<p>swift algorithm club (<a href="https://github.com/between40and2/swift-algorithm-club">between40and2</a>)</p>
<h2>Swift supports</h2>
<p><a href="https://developer.apple.com/reference/swift/array/1688499-sort">mutating func sort()</a></p>
<p><a href="https://developer.apple.com/reference/swift/array/2296801-sort">mutating func sort(by areInIncreasingOrder: (Element, Element) -&gt; Bool)</a></p>
<h3>Sort: In-place or new array<br>
</h3>
<p>initially, i thought, new-array sort can be derived from in-place sort, with following function,<br>
</p>
<p> func sorted(_ a : [ElementType]) -&gt; [ElementType] {<br>
  var array_internal = a<br>
  sort(&amp;array_internal)<br>
  return array_internal<br>}</p>
<p>However, some sort are implemented in new-array way.( such as Merge Sort) and some new-array way of sort, such as Heap Sort (see https://github.com/between40and2/swift-algorithm-club/tree/master/Heap%20Sort)</p>
<h2>where and how is comparison expressed?</h2>
<p>* class XALG_Sort_base &lt;Element: Comparable&gt;</p>
<p>* func mergeSort&lt;T: Comparable&gt;(_ array: [T]) -&gt; [T] {<br>
</p>
<p>* var isOrderedBefore : (T, T) -&gt; Bool // in Heap<br>
</p>
<h2>recursive vs iterative.. does it affect performance?? or pure style of coding?</h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Performance Comparison</h2>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>stable?</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Insertion 直接插入</td>
    <td>O(n)</td>
    <td>O(n^2)</td>
    <td>O(n^2)</td>
    <td>O(1)</td>
    <td>Y</td>
  </tr>
  <tr>
    <td>Selection 简单选择</td>
    <td>O(n^2)</td>
    <td>O(n^2)</td>
    <td>O(n^2)</td>
    <td>O(1)</td>
    <td>N</td>
  </tr>
  <tr>
    <td>Bubble 冒泡</td>
    <td>&nbsp;</td>
    <td>O(n^2)</td>
    <td>O(n^2)</td>
    <td>O(1)</td>
    <td>Y</td>
  </tr>
  <tr>
    <td>Shell 希尔</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>O(1)</td>
    <td>N</td>
  </tr>
  <tr>
    <td>Quick - D&amp;C</td>
    <td colspan="2">O(nlogn) </td>
    <td>O(n^2)</td>
    <td>O(1)</td>
    <td>N</td>
  </tr>
  <tr>
    <td>Merge - D&amp;C</td>
    <td colspan="3">O(nlogn)</td>
    <td>O(n)</td>
    <td>Y</td>
  </tr>
  <tr>
    <td>Heap</td>
    <td colspan="3">O(nlogn)</td>
    <td>O(1)</td>
    <td>N</td>
  </tr>
  <tr>
    <td>Radix 基数</td>
    <td colspan="3">O(d(2n+r))</td>
    <td>&nbsp;</td>
    <td>Y</td>
  </tr>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>
